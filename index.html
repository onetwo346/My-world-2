<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Realistic Sky & Land 3D Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body, html {
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: Arial, sans-serif;
            touch-action: none;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #joystick-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 100px;
            height: 100px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            z-index: 10;
            touch-action: none;
        }
        #joystick {
            position: relative;
            top: 25px;
            left: 25px;
            width: 50px;
            height: 50px;
            background-color: rgba(100, 149, 237, 0.8);
            border-radius: 50%;
            cursor: pointer;
            touch-action: none;
        }
        #loading {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(135, 206, 250, 0.7);
            color: white;
            z-index: 100;
            font-size: 24px;
        }
        #loading-progress {
            width: 80%;
            max-width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            width: 0%;
            background: white;
            transition: width 0.3s;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 10;
            max-width: 300px;
        }
        @media (max-width: 768px) {
            #joystick-container { bottom: 20px; right: 20px; }
            #instructions { font-size: 14px; max-width: 250px; }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Loading Realistic Simulation...</div>
        <div id="loading-progress">
            <div id="progress-bar"></div>
        </div>
    </div>
    <div id="instructions">
        Use the joystick or mouse drag to look around in 360Â°. Arrow keys also work.
    </div>
    <canvas id="canvas"></canvas>
    <div id="joystick-container">
        <div id="joystick"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Core variables
        let camera, scene, renderer;
        let sun, moon, sunLight, skyMaterial;
        let time = 12; // Start at noon (0-24 hours)
        const cycleSpeed = 0.005; // Slower cycle for realism
        let isUserInteracting = false, onPointerDownMouseX = 0, onPointerDownMouseY = 0;
        let lon = 0, onPointerDownLon = 0, lat = 0, onPointerDownLat = 0;
        let phi = 0, theta = 0;
        let joystick, joystickRect, joystickCenterX, joystickCenterY, joystickActive = false, joystickTouchId = null;
        let loadingElement, progressBar;

        // Noise function for terrain (simple Perlin-like noise)
        function noise(x, z) {
            return Math.sin(x * 0.1) * Math.cos(z * 0.1) + Math.random() * 0.5;
        }

        // Initialize the scene
        init();
        animate();

        function init() {
            loadingElement = document.getElementById('loading');
            progressBar = document.getElementById('progress-bar');

            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0); // Eye-level height

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Create environment
            createSky();
            createTerrain();
            setupJoystick();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
            document.addEventListener('keydown', onKeyDown);

            setTimeout(() => loadingElement.style.display = 'none', 2000);
        }

        function createSky() {
            updateProgress(10);

            // Skybox with atmospheric scattering
            const skyGeometry = new THREE.SphereGeometry(500, 60, 40);
            skyGeometry.scale(-1, 1, 1); // Inside-out

            const uniforms = {
                sunPosition: { value: new THREE.Vector3(0, 300, -400) },
                turbidity: { value: 2.0 },
                rayleigh: { value: 1.0 },
                mieCoefficient: { value: 0.005 },
                mieDirectionalG: { value: 0.8 }
            };

            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            const fragmentShader = `
                uniform vec3 sunPosition;
                uniform float turbidity;
                uniform float rayleigh;
                uniform float mieCoefficient;
                uniform float mieDirectionalG;
                varying vec3 vWorldPosition;
                void main() {
                    vec3 viewDir = normalize(vWorldPosition);
                    float sunfade = 1.0 - clamp(1.0 - exp(sunPosition.y / 450.0), 0.0, 1.0);
                    vec3 skyColor = mix(vec3(0.0, 0.1, 0.3), vec3(0.5, 0.7, 1.0), sunfade);
                    if (sunfade < 0.1) skyColor = mix(vec3(0.0, 0.0, 0.1), vec3(0.8, 0.5, 0.2), smoothstep(0.0, 0.1, sunfade));
                    gl_FragColor = vec4(skyColor, 1.0);
                }
            `;

            skyMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // Sun
            const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
            const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffffee });
            sun = new THREE.Mesh(sunGeometry, sunMaterial);
            scene.add(sun);

            // Moon
            const moonGeometry = new THREE.SphereGeometry(8, 32, 32);
            const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xaaaaaa });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            scene.add(moon);

            // Sunlight
            sunLight = new THREE.DirectionalLight(0xffffee, 1);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 1000;
            scene.add(sunLight);

            // Ambient light
            scene.add(new THREE.AmbientLight(0x404040, 0.3));

            // Stars
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            for (let i = 0; i < 1000; i++) {
                const x = (Math.random() - 0.5) * 1000;
                const y = Math.random() * 400 + 50;
                const z = (Math.random() - 0.5) * 1000;
                starVertices.push(x, y, z);
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1, transparent: true });
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);

            updateProgress(40);
        }

        function createTerrain() {
            updateProgress(50);

            // Terrain with PBR
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            groundGeometry.rotateX(-Math.PI / 2);
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i], z = vertices[i + 2];
                const distance = Math.sqrt(x * x + z * z);
                if (distance > 20) vertices[i + 1] = noise(x, z) * 10;
            }
            groundGeometry.computeVertexNormals();

            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x358c3b,
                roughness: 0.9,
                metalness: 0.1,
                flatShading: false
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.receiveShadow = true;
            scene.add(ground);

            // Environment details
            addEnvironmentDetails();

            updateProgress(80);
        }

        function addEnvironmentDetails() {
            // Clouds
            for (let i = 0; i < 10; i++) {
                const cloudGeometry = new THREE.SphereGeometry(Math.random() * 8 + 4, 8, 8);
                const cloudMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
                const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                cloud.position.set(Math.random() * 400 - 200, Math.random() * 50 + 100, Math.random() * 400 - 200);
                cloud.scale.y = 0.5;
                cloud.userData = { speed: Math.random() * 0.01 + 0.005 };
                scene.add(cloud);
            }

            // Trees
            function createTree(x, z) {
                const trunkGeometry = new THREE.CylinderGeometry(0.4, 0.6, 4, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.set(x, 2, z);
                trunk.castShadow = true;

                const leavesGeometry = new THREE.ConeGeometry(2.5, 6, 8);
                const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x2E8B57, roughness: 0.7 });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.set(x, 6, z);
                leaves.castShadow = true;

                scene.add(trunk, leaves);
            }

            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 60 + 40;
                createTree(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }
        }

        function setupJoystick() {
            joystick = document.getElementById('joystick');
            const joystickContainer = document.getElementById('joystick-container');
            joystickRect = joystickContainer.getBoundingClientRect();
            joystickCenterX = joystickRect.left + joystickRect.width / 2;
            joystickCenterY = joystickRect.top + joystickRect.height / 2;

            joystickContainer.addEventListener('pointerdown', onJoystickStart, { passive: false });
            document.addEventListener('pointermove', onJoystickMove, { passive: false });
            document.addEventListener('pointerup', onJoystickEnd);
            document.addEventListener('pointercancel', onJoystickEnd);

            updateProgress(90);
        }

        function onJoystickStart(event) {
            event.preventDefault();
            if (!joystickActive) {
                joystickActive = true;
                joystickTouchId = event.pointerId;
                joystick.style.transition = 'none';
                updateJoystickPosition(event.clientX, event.clientY);
            }
        }

        function onJoystickMove(event) {
            if (joystickActive && event.pointerId === joystickTouchId) {
                event.preventDefault();
                updateJoystickPosition(event.clientX, event.clientY);
            }
        }

        function onJoystickEnd(event) {
            if (joystickActive && event.pointerId === joystickTouchId) {
                joystickActive = false;
                joystick.style.transition = '0.2s';
                joystick.style.left = '25px';
                joystick.style.top = '25px';
            }
        }

        function updateJoystickPosition(clientX, clientY) {
            joystickRect = document.getElementById('joystick-container').getBoundingClientRect();
            joystickCenterX = joystickRect.left + joystickRect.width / 2;
            joystickCenterY = joystickRect.top + joystickRect.height / 2;

            let deltaX = clientX - joystickCenterX;
            let deltaY = clientY - joystickCenterY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxRadius = joystickRect.width / 2 - joystick.offsetWidth / 2;
            if (distance > maxRadius) {
                deltaX = deltaX * maxRadius / distance;
                deltaY = deltaY * maxRadius / distance;
            }

            joystick.style.left = (deltaX + joystickRect.width / 2 - joystick.offsetWidth / 2) + 'px';
            joystick.style.top = (deltaY + joystickRect.height / 2 - joystick.offsetHeight / 2) + 'px';

            lon += deltaX * 0.1;
            lat -= deltaY * 0.1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            joystickRect = document.getElementById('joystick-container').getBoundingClientRect();
            joystickCenterX = joystickRect.left + joystickRect.width / 2;
            joystickCenterY = joystickRect.top + joystickRect.height / 2;
        }

        function onPointerDown(event) {
            if (event.target.id !== 'joystick' && event.target.id !== 'joystick-container') {
                isUserInteracting = true;
                onPointerDownMouseX = event.clientX;
                onPointerDownMouseY = event.clientY;
                onPointerDownLon = lon;
                onPointerDownLat = lat;
            }
        }

        function onPointerMove(event) {
            if (isUserInteracting) {
                lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
                lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
            }
        }

        function onPointerUp() {
            isUserInteracting = false;
        }

        function onKeyDown(event) {
            switch (event.keyCode) {
                case 37: lon -= 2; break; // Left
                case 38: lat += 2; break; // Up
                case 39: lon += 2; break; // Right
                case 40: lat -= 2; break; // Down
            }
        }

        function updateDayNightCycle() {
            time = (time + cycleSpeed) % 24;
            const sunAngle = (time / 24) * Math.PI * 2 - Math.PI / 2;
            const moonAngle = sunAngle + Math.PI;

            // Sun position and intensity
            sun.position.set(Math.cos(sunAngle) * 400, Math.sin(sunAngle) * 400, -200);
            sunLight.position.copy(sun.position);
            sunLight.intensity = Math.max(0, Math.sin(sunAngle)) * 1.5;

            // Moon position
            moon.position.set(Math.cos(moonAngle) * 400, Math.sin(moonAngle) * 400, -200);
            moon.visible = sunLight.intensity < 0.2;

            // Update sky
            skyMaterial.uniforms.sunPosition.value.copy(sun.position);

            // Star visibility
            scene.children.forEach(child => {
                if (child.isPoints) child.material.opacity = 1 - Math.max(0, Math.sin(sunAngle));
            });

            // Cloud movement
            scene.children.forEach(child => {
                if (child.userData.speed) child.position.x += child.userData.speed;
                if (child.position.x > 200) child.position.x = -200;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            updateDayNightCycle();

            lat = Math.max(-85, Math.min(85, lat));
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);

            camera.lookAt(
                camera.position.x + Math.sin(phi) * Math.cos(theta),
                camera.position.y + Math.cos(phi),
                camera.position.z + Math.sin(phi) * Math.sin(theta)
            );

            renderer.render(scene, camera);
        }

        function updateProgress(percent) {
            progressBar.style.width = percent + '%';
        }

        window.addEventListener('load', () => updateProgress(100));
    </script>
</body>
</html>
