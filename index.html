<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Plains: Interstellar Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body, html {
            overflow: hidden;
            width: 100%;
            height: 100%;
            font-family: 'Arial', sans-serif;
            touch-action: none;
            background: #0a0a1e;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        #joystick-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.2), rgba(0, 0, 50, 0.5));
            border-radius: 50%;
            z-index: 10;
            touch-action: none;
        }
        #joystick {
            position: relative;
            top: 25px;
            left: 25px;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #00d4ff, #1e90ff);
            border-radius: 50%;
            box-shadow: 0 0 10px #00d4ff;
            cursor: pointer;
            touch-action: none;
        }
        #loading {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #0a0a1e, #1e1e3c);
            color: #fff;
            z-index: 100;
            font-size: 28px;
            text-shadow: 0 0 5px #00d4ff;
        }
        #loading-progress {
            width: 80%;
            max-width: 400px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        #progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00d4ff, #ff00ff);
            transition: width 0.3s;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 50, 0.7);
            padding: 10px 15px;
            border-radius: 5px;
            color: #fff;
            z-index: 10;
            max-width: 350px;
            font-size: 16px;
            text-shadow: 0 0 3px #00d4ff;
        }
        @media (max-width: 768px) {
            #joystick-container { bottom: 15px; right: 15px; }
            #instructions { font-size: 12px; max-width: 250px; }
        }
    </style>
</head>
<body>
    <div id="loading">
        <div>Initializing Cosmic Plains...</div>
        <div id="loading-progress">
            <div id="progress-bar"></div>
        </div>
    </div>
    <div id="instructions">
        W/S: Move forward/back | A/D: Strafe | Mouse/Joystick: Look around | Explore the cosmic plains!
    </div>
    <canvas id="canvas"></canvas>
    <div id="joystick-container">
        <div id="joystick"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Core variables
        let camera, scene, renderer;
        let skyMaterial, twinSuns = [], riftParticles;
        let velocity = new THREE.Vector3();
        const moveSpeed = 0.1, friction = 0.95;
        let keys = { w: false, s: false, a: false, d: false };
        let isUserInteracting = false, lon = 0, lat = 0, phi = 0, theta = 0;
        let joystick, joystickRect, joystickCenterX, joystickCenterY, joystickActive = false, joystickTouchId = null;
        let loadingElement, progressBar;
        let time = 0;

        // Improved fractal noise for terrain
        function fractalNoise(x, z, octaves = 4) {
            let total = 0, frequency = 0.05, amplitude = 1, maxValue = 0;
            for (let i = 0; i < octaves; i++) {
                total += Math.sin(x * frequency) * Math.cos(z * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
                frequency *= 2;
            }
            return total / maxValue * 10;
        }

        init();
        animate();

        function init() {
            loadingElement = document.getElementById('loading');
            progressBar = document.getElementById('progress-bar');

            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 5, 0); // Slightly elevated

            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Create cosmic environment
            createCosmicSky();
            createLivingTerrain();
            setupJoystick();
            setupControls();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);

            setTimeout(() => loadingElement.style.display = 'none', 2000);
        }

        function createCosmicSky() {
            updateProgress(10);

            // Cosmic void with shader magic
            const skyGeometry = new THREE.SphereGeometry(1000, 64, 64);
            skyGeometry.scale(-1, 1, 1);

            const uniforms = {
                time: { value: 0 },
                nebulaColor: { value: new THREE.Vector3(0.1, 0.3, 0.8) },
                riftIntensity: { value: 0.5 }
            };

            const vertexShader = `
                varying vec3 vWorldPosition;
                void main() {
                    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            const fragmentShader = `
                uniform float time;
                uniform vec3 nebulaColor;
                uniform float riftIntensity;
                varying vec3 vWorldPosition;
                void main() {
                    vec3 dir = normalize(vWorldPosition);
                    float noise = sin(dir.x * 5.0 + time) * cos(dir.y * 5.0 + time);
                    vec3 baseColor = mix(nebulaColor, vec3(0.8, 0.1, 0.5), noise * 0.5 + 0.5);
                    float rift = pow(abs(sin(dir.z * 10.0 + time * 2.0)), 10.0) * riftIntensity;
                    vec3 finalColor = mix(baseColor, vec3(1.0, 0.8, 0.2), rift);
                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            skyMaterial = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);

            // Twin suns
            for (let i = 0; i < 2; i++) {
                const sunGeometry = new THREE.SphereGeometry(15 - i * 5, 32, 32);
                const sunMaterial = new THREE.MeshBasicMaterial({ color: i === 0 ? 0xffddaa : 0xaaddff });
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                scene.add(sun);
                twinSuns.push(sun);

                const light = new THREE.PointLight(i === 0 ? 0xffddaa : 0xaaddff, 1.5, 1000);
                light.castShadow = true;
                scene.add(light);
                sun.add(light);
            }

            // Rift particles
            const particleGeometry = new THREE.BufferGeometry();
            const particleVertices = [];
            for (let i = 0; i < 2000; i++) {
                const x = (Math.random() - 0.5) * 1500;
                const y = (Math.random() - 0.5) * 1500;
                const z = (Math.random() - 0.5) * 1500;
                particleVertices.push(x, y, z);
            }
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
            const particleMaterial = new THREE.PointsMaterial({ color: 0xffccaa, size: 2, transparent: true, blending: THREE.AdditiveBlending });
            riftParticles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(riftParticles);

            scene.add(new THREE.AmbientLight(0x404060, 0.2));
            updateProgress(40);
        }

        function createLivingTerrain() {
            updateProgress(50);

            // Dynamic starlit terrain
            const groundGeometry = new THREE.PlaneGeometry(2000, 2000, 128, 128);
            groundGeometry.rotateX(-Math.PI / 2);
            const vertices = groundGeometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i], z = vertices[i + 2];
                vertices[i + 1] = fractalNoise(x, z) * (1 - Math.min(1, Math.sqrt(x * x + z * z) / 1000));
            }
            groundGeometry.computeVertexNormals();

            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a2a5a,
                roughness: 0.8,
                metalness: 0.3,
                emissive: 0x102040,
                emissiveIntensity: 0.5
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.receiveShadow = true;
            scene.add(ground);

            // Cosmic flora
            function createCosmicCrystal(x, z) {
                const crystalGeometry = new THREE.TetrahedronGeometry(Math.random() * 2 + 1);
                const crystalMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00d4ff,
                    emissive: 0x00aaff,
                    shininess: 100,
                    transparent: true,
                    opacity: 0.9
                });
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(x, fractalNoise(x, z) + 1, z);
                crystal.castShadow = true;
                crystal.rotation.y = Math.random() * Math.PI;
                scene.add(crystal);
            }

            for (let i = 0; i < 100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 800 + 100;
                createCosmicCrystal(Math.cos(angle) * radius, Math.sin(angle) * radius);
            }

            updateProgress(80);
        }

        function setupJoystick() {
            joystick = document.getElementById('joystick');
            const joystickContainer = document.getElementById('joystick-container');
            joystickRect = joystickContainer.getBoundingClientRect();
            joystickCenterX = joystickRect.left + joystickRect.width / 2;
            joystickCenterY = joystickRect.top + joystickRect.height / 2;

            joystickContainer.addEventListener('pointerdown', onJoystickStart, { passive: false });
            document.addEventListener('pointermove', onJoystickMove, { passive: false });
            document.addEventListener('pointerup', onJoystickEnd);
            document.addEventListener('pointercancel', onJoystickEnd);

            updateProgress(90);
        }

        function setupControls() {
            document.addEventListener('keydown', (e) => {
                switch (e.key) {
                    case 'w': keys.w = true; break;
                    case 's': keys.s = true; break;
                    case 'a': keys.a = true; break;
                    case 'd': keys.d = true; break;
                }
            });
            document.addEventListener('keyup', (e) => {
                switch (e.key) {
                    case 'w': keys.w = false; break;
                    case 's': keys.s = false; break;
                    case 'a': keys.a = false; break;
                    case 'd': keys.d = false; break;
                }
            });
        }

        function onJoystickStart(event) {
            event.preventDefault();
            if (!joystickActive) {
                joystickActive = true;
                joystickTouchId = event.pointerId;
                joystick.style.transition = 'none';
                updateJoystickPosition(event.clientX, event.clientY);
            }
        }

        function onJoystickMove(event) {
            if (joystickActive && event.pointerId === joystickTouchId) {
                event.preventDefault();
                updateJoystickPosition(event.clientX, event.clientY);
            }
        }

        function onJoystickEnd(event) {
            if (joystickActive && event.pointerId === joystickTouchId) {
                joystickActive = false;
                joystick.style.transition = '0.2s';
                joystick.style.left = '25px';
                joystick.style.top = '25px';
            }
        }

        function updateJoystickPosition(clientX, clientY) {
            joystickRect = document.getElementById('joystick-container').getBoundingClientRect();
            joystickCenterX = joystickRect.left + joystickRect.width / 2;
            joystickCenterY = joystickRect.top + joystickRect.height / 2;

            let deltaX = clientX - joystickCenterX;
            let deltaY = clientY - joystickCenterY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxRadius = joystickRect.width / 2 - joystick.offsetWidth / 2;
            if (distance > maxRadius) {
                deltaX = deltaX * maxRadius / distance;
                deltaY = deltaY * maxRadius / distance;
            }

            joystick.style.left = (deltaX + joystickRect.width / 2 - joystick.offsetWidth / 2) + 'px';
            joystick.style.top = (deltaY + joystickRect.height / 2 - joystick.offsetHeight / 2) + 'px';

            lon += deltaX * 0.1;
            lat -= deltaY * 0.1;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            joystickRect = document.getElementById('joystick-container').getBoundingClientRect();
            joystickCenterX = joystickRect.left + joystickRect.width / 2;
            joystickCenterY = joystickRect.top + joystickRect.height / 2;
        }

        function onPointerDown(event) {
            if (event.target.id !== 'joystick' && event.target.id !== 'joystick-container') {
                isUserInteracting = true;
                onPointerDownMouseX = event.clientX;
                onPointerDownMouseY = event.clientY;
                onPointerDownLon = lon;
                onPointerDownLat = lat;
            }
        }

        function onPointerMove(event) {
            if (isUserInteracting) {
                lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
                lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
            }
        }

        function onPointerUp() {
            isUserInteracting = false;
        }

        function updateCosmicEnvironment() {
            time += 0.01;

            // Twin suns orbit
            twinSuns[0].position.set(Math.cos(time) * 400, Math.sin(time * 0.7) * 300, Math.sin(time) * 400);
            twinSuns[1].position.set(Math.cos(time + Math.PI) * 350, Math.sin(time * 0.9) * 250, Math.sin(time + Math.PI) * 350);

            // Sky pulsation
            skyMaterial.uniforms.time.value = time;
            skyMaterial.uniforms.riftIntensity.value = 0.5 + Math.sin(time * 0.5) * 0.3;

            // Rift particle drift
            const positions = riftParticles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i] += Math.sin(time + positions[i + 1]) * 0.02;
                positions[i + 1] += Math.cos(time + positions[i]) * 0.01;
                if (positions[i] > 750) positions[i] = -750;
                if (positions[i + 1] > 750) positions[i + 1] = -750;
            }
            riftParticles.geometry.attributes.position.needsUpdate = true;

            // Terrain ripple
            const ground = scene.children.find(child => child.isMesh && child.geometry.type === 'PlaneGeometry');
            if (ground) {
                const vertices = ground.geometry.attributes.position.array;
                for (let i = 0; i < vertices.length; i += 3) {
                    const x = vertices[i], z = vertices[i + 2];
                    vertices[i + 1] = fractalNoise(x + time * 0.1, z) * (1 - Math.min(1, Math.sqrt(x * x + z * z) / 1000));
                }
                ground.geometry.attributes.position.needsUpdate = true;
                ground.geometry.computeVertexNormals();
            }
        }

        function updateMovement() {
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

            if (keys.w) velocity.add(forward.multiplyScalar(moveSpeed));
            if (keys.s) velocity.add(forward.multiplyScalar(-moveSpeed));
            if (keys.a) velocity.add(right.multiplyScalar(-moveSpeed));
            if (keys.d) velocity.add(right.multiplyScalar(moveSpeed));

            velocity.multiplyScalar(friction);
            camera.position.add(velocity);

            // Keep camera above terrain
            const ground = scene.children.find(child => child.isMesh && child.geometry.type === 'PlaneGeometry');
            if (ground) {
                const raycaster = new THREE.Raycaster(camera.position, new THREE.Vector3(0, -1, 0), 0, 10);
                const intersects = raycaster.intersectObject(ground);
                if (intersects.length > 0) {
                    camera.position.y = Math.max(camera.position.y, intersects[0].point.y + 2);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updateCosmicEnvironment();
            updateMovement();

            lat = Math.max(-85, Math.min(85, lat));
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);

            camera.lookAt(
                camera.position.x + Math.sin(phi) * Math.cos(theta),
                camera.position.y + Math.cos(phi),
                camera.position.z + Math.sin(phi) * Math.sin(theta)
            );

            renderer.render(scene, camera);
        }

        function updateProgress(percent) {
            progressBar.style.width = percent + '%';
        }

        window.addEventListener('load', () => updateProgress(100));
    </script>
</body>
</html>
